# Caching

## CloudFront

### Amazon CloudFront

- Content Delivery Network (CDN)
- Improves read performance, content is cached at the edge
- 225+ Point of Presence globally (215+ Edge Locations & 13 Regional Edge Caches)
- Protect against Network and Application layer attacks (e.g, DDos attacks)
- Integration with AWS Shield, AWS WAF, and Route 53
- Can expose external HTTPS and can talk to internal HTTPS backends
- Supports WebSocket protocol

### CloudFront - Origins

- S3 Bucket
    - For distributing files
    - Enhanced security with CloudFront Origin Access Control (OAC)
    - OAC is replacing Origin Access Identity (OAI)
    - CloudFront can be used as an ingress (to upload files to S3)
- S3 Bucket configured as a website
    - First, enable Static Website hosting on the bucket
- MediaStore Container & MediaPackage Endpoint
    - To deliver Video On Demand (VOD) or live streaming video using AWS Media Services
- Custom Origin (HTTP)
    - EC2 instance
    - Elastic Load Balancer (CLB or ALB)
    - API Gateway (for more control...otherwise use API Gateway Edge)
    - Any HTTP backend you want

### CloudFront - S3 as an Origin

- Origin (S3 bucket) -> OAC -> Origin Access Control + S3 bucket policy

### CloudFront vs S3 Cross Region Replication

- CloudFront
    - Global Edge network
    - Files are cached for a TTL (maybe a day)
    - Great for static content that must be available everywhere
- S3 Cross Region Replication
    - Must be setup for each region you want replication to happen
    - Files are updated in near real-time
    - Read only
    - Great for dynamic content that needs to be available at low-latency in few regions

### CloudFront - EC2 or ALB as an origin

- Edge Location -> Allow Public IP of Edge Locations -> EC2 Instance Must be Public
- Edge Location Public IPs -> Allow Public IP of Edge Locations -> Application Load Balancer Must be Public -> Allow
  Security Group of Load Balancer -> EC2 Instances Can be private

### CloudFront â€” Restrict Access to Application Load Balancers and Custom Origins

- Prevent direct access to your ALB or Custom Origins (only access through CloudFront)
- First, configure CloudFront to add a Custom HTTP Header to requests it sends to the ALB
- Second, configure the ALB to only forward requests that contain that Custom HTTP Header
- Keep the custom header name and value secret!
- You can also restrict access to CloudFront Public IP addresses ONLY

### CloudFront - Origin Groups

- To increase high-availability and do failover
- Origin Group: one primay and one secondary origin
- if the primary origin fails, the second one is used
- Origins can be cores AWS Regions

### CloudFront Geo Restriction

- You can restrict who can access your distribution
    - Allow list: Allow your users to access your content only if they're in one of the countries on a list of approved
      countries
    - Block list: Prevent your users from accessing your content if they're in one of the countries on a blacklist of
      banned countries
- The "country" is determined using a 3rd party Geo-IP database
- Use case: Copyright Laws to control access to content
- Note: the geo header `CloudFront-Viewer-Country` is in Lambda@Edge

### CloudFront- Pricing

- CloudFront Edge locations are around the world
- The cost of data put per edge location varies

### CloudFront - Price Classes

- You can reduce the number of edge locations for cost reduction
- Three price classes
    - Price Class All: all regions - best performance
    - Price Class 200: most regions, but excludes the most expensive regions
    - Price Class 100: only the least expensive regions

### CloudFront Signed URL Diagram

- Signed URL with expiration to control access to content in CloudFront
- The Signed URL are generated by an API call into CloudFront as a trusted signer

### CloudFront Signed URL vs S3 Pre-Signed URL

- CloudFront Signed URL
    - Allow access to a path, no matter the origin
    - Account wide key-pair, only the root can manage it
    - Can filter by IP, path, date, expiration
    - Can leverage caching features
- S3 Pre-Signed URL
    - Issue a request as the person who pre-signed the URL
    - Uses the IAM key of the signing IAM principal
    - Limited lifetime

### CloudFront - Custom Error Pages

- Return an object to the viewer (e.g, html) when your origin returns an HTTP 4xx or 5xx status code to CloudFront
- Use Error Caching Minimum TTL to specify how long CloudFront caches the custom error pages

## Lambda@Edge and CloudFront Functions

### CloudFront - Customization At The Edge

- Many modern applications execute some form of the logic at the edge
- Edge Function
    - A code that you write and attach to CloudFront distributions
    - Runs close to your users to minimize latency
    - Doesn't have any cache, only to change requests/responses
    - CloudFront provides two types: CloudFront Functions & Lambda@Edge
- Use cases:
    - Manipulate HTTP requests and responses
    - Implement request filtering before reaching your application
    - User authentication and authorization
    - Generate HTTP responses at the edge
    - A/B Testing
    - Bot mitigation at the edge
    - You don't have to manage any servers, deploy globally

### CloudFront Functions & Lambda@Edge

- Client -> Edge Location -> Regional Edge Cache -> Origin
- CloudFront Functions are deployed at Edge Location
- Lambda@Edge Functions are deployed at Regional Edge Cache

### CloudFront - CloudFront Functions

- Lightweight functions written in JavaScript
- For high-scale, latency-sensitive CDN customizations
- Sub-ms startup times, millions of requests/second
- Run at Edge Locations
- Process-based isolation
- Used to change Viewer requests and responses
    - Viewer Request: after CloudFront receives a request from a viewer
    - Viewer Response: before CloudFront forwards the response to the viewer
- Native feature of CloudFront (manage code entirely within CloudFront)

### CloudFont - Lambda@Edge

- Lambda functions written in NodeJS or Python
- Scales to 1000s of requests/second
- Runs at the nearest Regional Edge Cache
- VM-based isolation
- Used to change CloudFront requests and responses
    - Viewer Request - after CloudFront receives a request from a viewer
    - Origin Request - before CloudFront forwards the request to the origin
    - Origin Response - after CloudFront receives the response from the origin
    - Viewer Response - before CloudFront forwards the response to the viewer
- Author your functions in one AWS Region (us-eas-1), then CloudFront replicates to its locations

### CloudFront Functions with Lambda@Edge

- CloudFront Functions and Lambda@Edge can be used together
- CloudFront Functions for Viewer part and Lambda@Edge for Origin part

### Using Lambda@Edge only

- Use when you need some of the capabilities of Lambda@Edge that aren't available with CloudFront Functions (e.g, longer
  execution time, network access,...)
- Lambda@Edge for both Viewer and Origin part

### CloudFront Functions vs. Lambda@Edge

- CloudFront Functions
    - Runtime Support
        - JavaScript
    - Execution Location
        - Edge Locations
    - CloudFront Triggers
        - Viewer Request/Response
    - Isolation
        - Process-based
    - Max. Execution Time
        - < 1ms
    - Max.Memory
        - 2MB
    - Total Package Size
        - 10KB
    - Network Access, File System Access
        - No
    - Access to the Request Body
        - No
    - Pricing
        - Free tier available, 1/6th price of @Edge
- Lambda@Edge
    - Runtime Support
        - Node.js, Python
    - Execution Location
        - Regional Edge Caches
    - CloudFront Triggers
        - Viewer Request/Response
        - Origin Request/Response
    - Isolation
        - VS-based
    - Max. Execution Time
        - 5 seconds (viewer triggers)
        - 30 seconds (origin triggers)
    - Max.Memory
        - 128MB (viewer triggers)
        - 10GB (origin triggers)
    - Total Package Size
        - 1MB (viewer triggers)
        - 50MB (origin triggers)
    - Network Access, File System Access
        - Yes
    - Access to the Request Body
        - Yes
    - Pricing
        - No free tier, charged per request & duration

### CloudFront Functions vs. Lambda@Edge - Use Cases

- CloudFront Functions
    - Cache key normalization
        - Transform request attributes (headers, cookies, query strings, URL) to create an optimal Cache Key
    - Header manipulation
        - Insert/modify/delete HTTP headers in the request or response
    - URL rewrites or redirects
    - Request authentication & authorization
        - Create and validate user-generated tokens (e.g, JWT) to allow/deny requests
- Lambda@Edge
    - Longer execution time (several ms)
    - Adjustable CPU or memory
    - Your code depends on a 3rd libraries (e.g, AWS SDK to access other AWS services)
    - Network access to use external services for processing
    - File system access or access to the body of HTTP requests

### CloudFront Functions vs. Lambda@Edge - Authentication and Authorization

- CloudFront Functions
    - Client -> request -> Amazon CloudFront -> Edge Location -> CloudFront Function intercept -> check authentication
      and authorization (e.g, validateJWT tokens) -> forward -> Origin
- Lambda@Edge
    - Client -> request -> Amazon CloudFront -> Regional Edge Cache -> LambdaFunction@Edge intercept -> Check
      authentication and authorization -> Cognito or 3rd party OIDC -> forward -> Origin

### Lambda@Edge: Loading content based on User-Agent

- Lambda@Edge Function can inspect User-Agent HTTP Header
- Redirect based on Device Type

### Lambda@Edge - Global Application

- Client -> HTML website -> S3 Bucket (Static Website Hosting)
- Client -> dynamic API requests -> CloudFront -> Lambda@Edge Function -> query data -> DynamoDB

## Lambda@Edge  Reduce Latency

### Lambda@Edge - Route to Difference Origin

- Users (Europe) -> Index.html -> If cached, return object -> trigger Origin Request Lambda@Edge function -> Modify
  Origin -> us-east-1 / eu-west-2 -> S3 Bucket (Website Hosting Enabled) -> Return Object
- S3 Cross-Region Replication

## Amazon Elasticache

### Amazon ElasticCache Overview

- The sameway RDS is to get managed Relational Databases...
- ElastiCache is to get managed Redis or Memcached
- Caches are in-memory databases with really high performance, low latency
- Help reduce load off of databases for read intensive workloads
- Helps make your application stateless
- AWS takes care of OS maintenance / patching, optimizations, setup, configuration, monitoring, failure recovery and
  backups
- Using ElasitCache involves heavy application code changes

### ElastiCache Solution Architecture - DB Cache

- Application queries ElastiCache, if not available, get from RDS and store in ElastiCache
- Helps relive load in RDS
- Cache must have an invalidation strategy to make sure only the most current data is used in there

### ElastiCache Solution Architecture - Uer Session Store

- Use logs into any of the application
- The application writes the session data into ElastiCache
- The user hits another instance of our application
- The instance retrieves the data the user is already logged in

## ElastiCache - Redis vs Memcached

- Redis
    - Multi AZ with Auto-Failover
    - Read Replicas to scale reads and high availability
    - Persistent, Data Durability: Read Only File Feature (AOF), backup and restore features
- Memcached
    - Multi-node for partitioning of data (sharding)
    - Non persistent
    - No backup and restore
    - Multi-threaded architecture

## Handling Extreme Rates

- Client -> Route 53 (global)
- -> CloudFront (100000 RPS) -> ALB / API Gateway - 10000 RPS -> Compute Layer (ASG ECS - slow, bootstrap, Fargate -
  faster, Lambda - 1000 concurrent)
- -> Redis - < 200 nodes (replica + sharding), Memcached - 20 nodes (sharding), DAX - 10 nodes (primary + replicas)
- -> Database Layer: RDS, Aurora, ElastiSearch - provisioned; DynamoDB - auto scaling, on-demand
- -> SQS, SNS - unlimited, SQS FIFO - 3000 RPS (with batching), Kinesis - 1MB/s in, 2MB/s our per shard
- -> EBS - 16k IOPS (gp2), 64K IOPS (io1), Instance Store - ~M IOPS, EFS - General, Max IO
- -> S3 - 3500 PUT, 5500 GET per prefix /s, KMS limits if encrypted













